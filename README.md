
#### Ковалёв Евгений  
#### Курсовая работа по курсу "Многопоточное и асинхронное программирование на Java"  
#### МИФИ, магистратура ИИКС, 1 курс  

-------------

# CustomThreadPool — Пользовательский пул потоков с Least Loaded балансировкой  

## Описание проекта  

Проект представляет собой реализацию **кастомного пула потоков (`CustomThreadPool`)** на Java. Реализация включает поддержку:  

- Least Loaded балансировки (распределение задач между потоками по минимальной загрузке)  
- Динамического расширения пула  
- Логирования и его отключения  
- Политики обработки отказов (например, `CallerRunsPolicy`)  
- Сравнения производительности с пулом из стандартной библиотеки (`ThreadPoolExecutor`)  

Целью является **анализ поведения кастомного пула при различных конфигурациях**, а также сравнение его с пулами из стандартной библиотеки.  

---  

## Принцип работы балансировки  

### Least Loaded (наименьшая загрузка)  

Наш пул использует **алгоритм Least Loaded** для распределения задач:  

- Каждая задача отправляется **воркеру с наименьшей длиной очереди**.  
- Это позволяет равномерно распределять нагрузку между потоками.  
- Уменьшает время ожидания выполнения задач.  

---  

## Содержание и архитектура проекта  

```
.
├── Main.java
├── CustomThreadPool.java
├── ThreadPoolConstants.java
├── MyThreadFactory.java
├── CustomExecutor.java
├── CallerRunsPolicy.java
└── README.md
```  

| Компонент | Назначение |  
|-----------|------------|  
| `CustomThreadPool` | Основной класс пула потоков |  
| `Worker` *(внутренний класс)* | Отвечает за выполнение задач внутри каждого потока |  
| `MyThreadFactory` | Фабрика потоков с именованием и обработкой исключений |  
| `CustomExecutor` | Интерфейс, определяющий API пула |  
| `CallerRunsPolicy` | Политика обработки отказа: выполняет задачу в текущем потоке |  
| `Main.java` | Точка входа и бенчмарк-тестирование |  
| `ThreadPoolConstants.java` | Хранит константы параметров пула и тестовых задач |  

---  

## Информация о внутреннем классе `Worker`  

Класс `Worker` — это **внутренний класс** внутри `CustomThreadPool`, реализующий интерфейс `Runnable`. Он:  

- создаётся фабрикой потоков  
- имеет собственную очередь задач (`ArrayBlockingQueue`)  
- проверяет состояние пула перед выполнением задачи  
- завершается, если:  
   - задач нет в очереди и число активных потоков > `corePoolSize`  
   - был вызван `shutdown()`  
   - была получена команда `interrupt()`  

---  

## Как запустить проект  

1. Убедитесь, что у вас установлен JDK 8+.  
2. Скомпилируйте проект или откройте его в IDE (IntelliJ IDEA / Eclipse).  
3. Запустите файл `Main.java`.  
4. Результаты будут выведены в консоль и включать:  
   - параметры пула  
   - количество выполненных/отклонённых задач  
   - время выполнения  
   - пропускную способность  

> **Примечание:** По умолчанию логирование **выключено**. Чтобы включить, вызовите `setEnableLogging(true)` в коде пула.  

---  

## Тестирование  

Было проведено **5 сценариев** тестирования с разными параметрами для кастомного и стандартного (`ThreadPoolExecutor`) пулов:  

| Сценарий | corePoolSize | maxPoolSize | queueSize | minSpareThreads |  
|----------|--------------|-------------|-----------|------------------|  
| 1        | 2            | 4           | 5         | 1                |  
| 2        | 2            | 2           | 5         | 1                |  
| 3        | 2            | 8           | 10        | 1                |  
| 4        | 2            | 4           | 2         | 1                |  
| 5        | 4            | 6           | 10        | 1                |  

---  

## Результаты тестирования  

| Сценарий | Пул | corePoolSize | maxPoolSize | queueSize | minSpareThreads | Выполнено | Отклонено | Время (ms) | Пропускная способность (tasks/sec) |  
|----------|-----|--------------|-------------|-----------|------------------|-----------|-----------|------------|------------------------------------|  
| 1        | Custom | 2            | 4           | 5         | 1                | 84        | 16        | 1776       | ~47.3                              |  
| 1        | Standard | 2          | 4           | 5         | 0                | 100       | 0         | 2344       | ~42.7                              |  
| 2        | Custom | 2            | 2           | 5         | 1                | 70        | 30        | 3343       | ~20.9                              |  
| 2        | Standard | 2          | 2           | 5         | 0                | 100       | 0         | 3866       | ~25.9                              |  
| 3        | Custom | 2            | 8           | 10        | 1                | 98        | 2         | 609        | ~160.9                             |  
| 3        | Standard | 2          | 8           | 10        | 0                | 100       | 0         | 1342       | ~74.5                              |  
| 4        | Custom | 2            | 4           | 2         | 1                | 82        | 18        | 1995       | ~41.1                              |  
| 4        | Standard | 2          | 4           | 2         | 0                | 100       | 0         | 2891       | ~34.6                              |  
| 5        | Custom | 4            | 6           | 10        | 1                | 94        | 6         | 891        | ~105.5                             |  
| 5        | Standard | 4          | 6           | 10        | 0                | 100       | 0         | 1693       | ~59.1                              |  

---  

## Анализ производительности  

### Когда кастомное решение лучше?  

- **Кастомный пул показывает лучшие результаты** в сценариях с большим количеством свободных потоков и большими очередями.  
- При **правильном подборе параметров** он может работать **значительно быстрее** стандартного пула.  
- Самая оптимальная работа кастомного пула наблюдается при количестве задач примерно равном `maxPoolSize` * `queueSize`.  

### Когда кастомное решение хуже?  

- Кастомный пул **может отклонять задачи**, если очередь переполнена.  
- При **слишком малых параметрах** (например, когда `corePoolSize == maxPoolSize`) кастомный пул работает хуже стандартного.  

---  

## Мини-исследование параметров пула  

| Параметр | Оптимальное значение | Почему |  
|----------|----------------------|--------|  
| `corePoolSize` | 2–4                  | Баланс между стабильностью и масштабируемостью |  
| `maxPoolSize` | 4–8                 | Позволяет адаптироваться к нагрузкам |  
| `queueSize` | 5–10               | Чем больше — тем меньше реджектов |  
| `minSpareThreads` | 1             | Гарантирует наличие "резервных" потоков |  
| `keepAliveTime` | 5 секунд         | Не слишком часто завершает потоки |  

> **Рекомендация:** **Лучший сценарий** — `corePoolSize=2`, `maxPoolSize=8`, `queueSize=10`.  
> В этом случае кастомный пул показывает **пропускную способность более чем в два раза выше**, чем стандартный пул.  

---  

## Выводы  

- Кастомный пул **подходит для специфических сценариев**, где требуется точная настройка.  
- Механизм **Least Loaded** позволяет **лучше использовать ресурсы**, особенно при высоких нагрузках.  
- Важно правильно выбирать параметры пула, чтобы не было **отказов и задержек**.  
